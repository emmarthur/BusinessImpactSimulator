## Learning Log

### FastAPI Basics
- Created an app instance: `app = FastAPI()` to define API routes.
- Added a simple route with `@app.get("/")` that returns JSON.

### Decorators (e.g., `@app.post`)
- A decorator modifies a function’s behavior. `@app.post("/path")` registers the function as the handler for POST requests to that path.
- Benefits: Clear, declarative routing; keeps function code focused on logic.

### Request Body with `Body(..., embed=True)`
- `description: str` enforces type (validates input is a string).
- `Body(...)` tells FastAPI to read from the JSON body instead of query params; `...` means required.
- `embed=True` expects a JSON object like `{ "description": "..." }` instead of a raw string.

### Running the Server
- Start with Uvicorn inside `main.py` (configured to port 8001). Access at `http://localhost:8001/`.
- Interactive docs available at `http://localhost:8001/docs` (auto-generated by FastAPI).

### CORS (Cross-Origin Resource Sharing)
- Needed because the React frontend (`http://localhost:5173`) calls the API on a different origin (`http://localhost:8001`).
- Allowing specific origins via CORS middleware permits the browser to make these cross-origin requests safely.

### Frontend vs Backend
- React dev server and FastAPI run on different ports and communicate via HTTP (e.g., POST to `/api/process-project`).

### CORS Middleware Call Explained
- `app.add_middleware(CORSMiddleware, ...)`: Enables CORS handling for the app.
- `allow_origins=["http://localhost:5173"]`: Only allows requests from the React dev server.
- `allow_methods=["*"]`: Permits all HTTP methods (GET, POST, etc.). You can restrict later.
- `allow_headers=["*"]`: Permits all custom/request headers (like `Content-Type`).

Effect: The browser receives the correct CORS headers on responses so it won’t block cross-origin requests from the frontend to the backend.

### React Button Elements
- Basic format: `<button type="button">Label</button>` creates a clickable button that does nothing by default.
- With a click handler: `<button type="button" onClick={() => { /* code here */ }}>Label</button>` runs the function when clicked.
- `type="button"` prevents the button from submitting a form unintentionally when nested in a form.

### React useState (state in function components)
- `useState('')` initializes a state value with an empty string.
- The array destructuring gives you two things:
  - `description`: the current state value
  - `setDescription`: a function to update that value
- Calling `setDescription(newValue)` updates the state and triggers a re-render so the UI reflects the new value.
- This state is local to the `App` component instance and persists across re-renders.
- Common use: bind an input’s `value` to `description` and update it with `onChange={(e) => setDescription(e.target.value)}`.

### Controlled inputs: why we use `setDescription`
- Binding `value={description}` makes the input controlled by React; the state is the single source of truth.
- `setDescription(...)` updates that state when the user types, keeping the UI and data in sync.
- Without `setDescription`, a controlled input becomes read-only; without `value`, the input is uncontrolled and harder to validate, reset, or submit reliably.
- Benefits of controlled inputs: easy validation, enabling/disabling buttons, live character counts, clearing the field after submit, and sending the exact state to the backend.

### React onClick: sending a POST to the backend
- `onClick={async () => { ... }}` attaches a click handler that runs when the button is pressed.
- Inside, `fetch('http://localhost:8001/api/process-project', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ description }) })` sends the current text as JSON to the FastAPI endpoint.
- `await res.json()` reads the JSON response from the server; logging it helps verify end-to-end connectivity.
- Because we send JSON, the browser performs a CORS preflight (OPTIONS). Our CORS middleware allows this request from `http://localhost:5173`.

### Handling async errors in React fetch
- Wrap your `await fetch(...)` in a `try/catch` to handle network failures or thrown errors.
- Always check `res.ok` (HTTP 2xx) before parsing the body; throw if not ok to route into `catch`.
- Use `finally` to clean up (e.g., stop a loading spinner) regardless of success/failure.

Example flow (conceptual):
```ts
try {
  const res = await fetch(url, options);
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  const data = await res.json();
  // handle success
} catch (err) {
  // handle error (log, show message)
} finally {
  // cleanup
}
```

### React function `submitDescription`
- Purpose: Send the current text to the backend and handle the response/errors.
- Flow:
  1) Builds a POST request to `http://localhost:8001/api/process-project` with JSON body `{ description: text }` and `Content-Type: application/json`.
  2) Awaits the response and checks `res.ok` (HTTP 2xx). Throws if not ok so errors are caught.
  3) Parses the JSON with `await res.json()` and logs/returns the data.
  4) Catches network/HTTP errors and logs them; rethrows if the caller needs to handle them.
- Why a named function: Reusable from multiple buttons/forms, easier to test, clearer stack traces, simpler to add loading/error UI state.

### Button loading state pattern
- `{isSubmitting ? 'Sending…' : 'Submit to backend'}`: a ternary expression that chooses the button label based on the boolean `isSubmitting`.
- `disabled={isSubmitting}`: prevents duplicate clicks while the request is in progress.
- `aria-busy={isSubmitting}`: accessibility hint that the control is busy.
- State: `const [isSubmitting, setIsSubmitting] = useState(false)` tracks whether a request is active.
- Flow inside the submit function:
  - `setIsSubmitting(true)` before starting the async work
  - `try { /* await fetch */ } catch (err) { /* handle error */ } finally { setIsSubmitting(false) }`
  - `finally` runs whether the request succeeds or fails, ensuring the button re-enables.

### async/await
- `async` marks a function as asynchronous (it can pause and resume).
- `await` pauses the function until a Promise resolves (e.g., `fetch` or `res.json()`).
- Why needed: `fetch` returns a Promise; without `await`, you get the Promise object, not the actual response.
- Use with try/catch: async functions can throw errors, so wrap `await` calls in try/catch to handle failures gracefully.
- Example: `async function submit() { try { const res = await fetch(url); const data = await res.json(); } catch (err) { /* handle error */ } }`

### Promise objects
- A Promise is a placeholder for a future value (like a "receipt" for work that's still happening).
- Without `await`, you get the Promise object itself, not the actual result.
- Promises have states: pending (work in progress), fulfilled (success), or rejected (error).
- `await` "unwraps" the Promise to get the actual value once it's ready.

### await for file operations
- `await file.read()` pauses until the file is fully read into memory (returns bytes).
- Why needed: File I/O is slow; without `await`, you'd get a Promise object instead of the actual file content.
- `.decode()` converts bytes to a string (assuming UTF-8 text files).
- Example: `content = await file.read(); text = content.decode()` gives you the file's text content.
